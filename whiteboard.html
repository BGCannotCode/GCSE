<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Infinite Canvas</title>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #f0f0f0;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: calc(100% - 40px);
            max-width: 1200px;
            box-sizing: border-box;
        }

        #canvas {
            display: block;
        }


        .control-item {
            margin: 0 10px;
            display: flex;
            align-items: center;
        }

        .control-item label {
            margin-right: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .control-item input[type="color"],
        .control-item input[type="range"],
        .control-item button {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .control-item button {
            background-color: #007bff;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .control-item button:hover {
            background-color: #0056b3;
        }
    </style>
</head>

<body>
    <div id="controls">
        <div class="control-item">
            <label for="colorPicker">Color:</label>
            <input type="color" id="colorPicker" value="#000000">
        </div>
        <div class="control-item">
            <label for="lineWidth">Width:</label>
            <input type="range" id="lineWidth" min="1" max="10" value="3">
        </div>
        <div class="control-item">
            <button id="toggleGrid">Toggle Grid</button>
        </div>
        <div class="control-item">
            <label for="gridSize">Grid Size:</label>
            <input type="range" id="gridSize" min="10" max="100" value="40">
        </div>
        <div class="control-item">
            <button id="undoButton">Undo</button>
        </div>
        <div class="control-item">
            <button id="redoButton">Redo</button>
        </div>
        <div class="control-item">
            <button id="clearCanvas">Clear Canvas</button>
        </div>
        <div class="control-item">
            <button id="exportButton">Export as PNG</button>
        </div>
    </div>

    <canvas id="canvas">Your browser does not support HTML5 canvas</canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");

        document.oncontextmenu = function () {
            return false;
        }

        const drawings = [];
        const undoneDrawings = [];

        let cursorX, cursorY, prevCursorX, prevCursorY;
        let offsetX = 0, offsetY = 0;
        let scale = 1;
        let drawingColor = '#000000';
        let drawingWidth = 3;
        let showGrid = false;
        let gridSize = 40;

        const colorPicker = document.getElementById("colorPicker");
        const lineWidth = document.getElementById("lineWidth");
        const clearCanvasButton = document.getElementById("clearCanvas");
        const undoButton = document.getElementById("undoButton");
        const redoButton = document.getElementById("redoButton");
        const exportButton = document.getElementById("exportButton");
        const toggleGridButton = document.getElementById("toggleGrid");
        const gridSizeSlider = document.getElementById("gridSize");

        colorPicker.addEventListener("input", (e) => {
            drawingColor = e.target.value;
        });

        lineWidth.addEventListener("input", (e) => {
            drawingWidth = e.target.value;
        });

        clearCanvasButton.addEventListener("click", () => {
            drawings.length = 0;
            undoneDrawings.length = 0;
            redrawCanvas();
        });

        undoButton.addEventListener("click", () => {
            if (drawings.length > 0) {
                undoneDrawings.push(drawings.pop());
                redrawCanvas();
            }
        });

        redoButton.addEventListener("click", () => {
            if (undoneDrawings.length > 0) {
                drawings.push(undoneDrawings.pop());
                redrawCanvas();
            }
        });

        exportButton.addEventListener("click", () => {
            const link = document.createElement('a');
            link.download = 'canvas.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        toggleGridButton.addEventListener("click", () => {
            showGrid = !showGrid;
            redrawCanvas();
        });

        gridSizeSlider.addEventListener("input", (e) => {
            gridSize = parseInt(e.target.value);
            redrawCanvas();
        });

        function toScreenX(xTrue) {
            return (xTrue + offsetX) * scale;
        }

        function toScreenY(yTrue) {
            return (yTrue + offsetY) * scale;
        }

        function toTrueX(xScreen) {
            return (xScreen / scale) - offsetX;
        }

        function toTrueY(yScreen) {
            return (yScreen / scale) - offsetY;
        }

        function trueHeight() {
            return canvas.clientHeight / scale;
        }

        function trueWidth() {
            return canvas.clientWidth / scale;
        }

        function drawGrid() {
            context.strokeStyle = 'rgba(0,0,0,0.1)';
            context.lineWidth = 1;
            for (let x = -offsetX % gridSize; x < canvas.width; x += gridSize) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }
            for (let y = -offsetY % gridSize; y < canvas.height; y += gridSize) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(canvas.width, y);
                context.stroke();
            }
        }

        function redrawCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            if (showGrid) {
                drawGrid();
            }

            for (let i = 0; i < drawings.length; i++) {
                const line = drawings[i];
                drawLine(toScreenX(line.x0), toScreenY(line.y0), toScreenX(line.x1), toScreenY(line.y1), line.color, line.width);
            }
        }
        redrawCanvas();

        window.addEventListener("resize", (event) => {
            redrawCanvas();
        });

        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mouseup', onMouseUp, false);
        canvas.addEventListener('mouseout', onMouseUp, false);
        canvas.addEventListener('mousemove', onMouseMove, false);
        canvas.addEventListener('wheel', onMouseWheel, false);

        canvas.addEventListener('touchstart', onTouchStart);
        canvas.addEventListener('touchend', onTouchEnd);
        canvas.addEventListener('touchcancel', onTouchEnd);
        canvas.addEventListener('touchmove', onTouchMove);

        let leftMouseDown = false;
        let rightMouseDown = false;

        function onMouseDown(event) {
            if (event.button == 0) {
                leftMouseDown = true;
                rightMouseDown = false;
            }
            if (event.button == 2) {
                rightMouseDown = true;
                leftMouseDown = false;
            }

            cursorX = event.pageX;
            cursorY = event.pageY;
            prevCursorX = event.pageX;
            prevCursorY = event.pageY;
        }

        function onMouseMove(event) {
            cursorX = event.pageX;
            cursorY = event.pageY;
            const scaledX = toTrueX(cursorX);
            const scaledY = toTrueY(cursorY);
            const prevScaledX = toTrueX(prevCursorX);
            const prevScaledY = toTrueY(prevCursorY);

            if (leftMouseDown) {
                drawings.push({
                    x0: prevScaledX,
                    y0: prevScaledY,
                    x1: scaledX,
                    y1: scaledY,
                    color: drawingColor,
                    width: drawingWidth
                });
                drawLine(prevCursorX, prevCursorY, cursorX, cursorY, drawingColor, drawingWidth);
            }
            if (rightMouseDown) {
                offsetX += (cursorX - prevCursorX) / scale;
                offsetY += (cursorY - prevCursorY) / scale;
                redrawCanvas();
            }
            prevCursorX = cursorX;
            prevCursorY = cursorY;
        }

        function onMouseUp(event) {
            leftMouseDown = false;
            rightMouseDown = false;
        }

        function drawLine(x0, y0, x1, y1, color, width) {
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.strokeStyle = color;
            context.lineWidth = width;
            context.stroke();
            context.closePath();
        }

        function onMouseWheel(event) {
            const scaleAmount = event.deltaY * -0.01;
            scale += scaleAmount;

            const mouseX = event.pageX / canvas.clientWidth;
            const mouseY = event.pageY / canvas.clientHeight;

            const unitsZoomedX = trueWidth() * scaleAmount;
            const unitsZoomedY = trueHeight() * scaleAmount;

            const unitsAddLeft = unitsZoomedX * mouseX;
            const unitsAddTop = unitsZoomedY * mouseY;

            offsetX -= unitsAddLeft;
            offsetY -= unitsAddTop;

            redrawCanvas();
        }

        const prevTouches = [null, null];
        let singleTouch = false;
        let doubleTouch = false;

        function onTouchStart(event) {
            if (event.touches.length == 1) {
                singleTouch = true;
                doubleTouch = false;
            }
            if (event.touches.length >= 2) {
                singleTouch = false;
                doubleTouch = true;
            }

            prevTouches[0] = event.touches[0];
            prevTouches[1] = event.touches[1];
        }

        function onTouchMove(event) {
            const touch0X = event.touches[0].pageX;
            const touch0Y = event.touches[0].pageY;
            const prevTouch0X = prevTouches[0].pageX;
            const prevTouch0Y = prevTouches[0].pageY;

            const scaledX = toTrueX(touch0X);
            const scaledY = toTrueY(touch0Y);
            const prevScaledX = toTrueX(prevTouch0X);
            const prevScaledY = toTrueY(prevTouch0Y);

            if (singleTouch) {
                drawings.push({
                    x0: prevScaledX,
                    y0: prevScaledY,
                    x1: scaledX,
                    y1: scaledY,
                    color: drawingColor,
                    width: drawingWidth
                });
                drawLine(prevTouch0X, prevTouch0Y, touch0X, touch0Y, drawingColor, drawingWidth);
            }

            if (doubleTouch) {
                const touch1X = event.touches[1].pageX;
                const touch1Y = event.touches[1].pageY;
                const prevTouch1X = prevTouches[1].pageX;
                const prevTouch1Y = prevTouches[1].pageY;

                const midX = (touch0X + touch1X) / 2;
                const midY = (touch0Y + touch1Y) / 2;
                const prevMidX = (prevTouch0X + prevTouch1X) / 2;
                const prevMidY = (prevTouch0Y + prevTouch1Y) / 2;

                const hypot = Math.sqrt(Math.pow((touch0X - touch1X), 2) + Math.pow((touch0Y - touch1Y), 2));
                const prevHypot = Math.sqrt(Math.pow((prevTouch0X - prevTouch1X), 2) + Math.pow((prevTouch0Y - prevTouch1Y), 2));

                const zoomAmount = hypot / prevHypot;
                scale *= zoomAmount;
                const scaleAmount = 1 - zoomAmount;

                const panX = midX - prevMidX;
                const panY = midY - prevMidY;
                offsetX += (panX / scale);
                offsetY += (panY / scale);

                const zoomRatioX = midX / canvas.clientWidth;
                const zoomRatioY = midY / canvas.clientHeight;

                const unitsZoomedX = trueWidth() * scaleAmount;
                const unitsZoomedY = trueHeight() * scaleAmount;

                const unitsAddLeft = unitsZoomedX * zoomRatioX;
                const unitsAddTop = unitsZoomedY * zoomRatioY;

                offsetX += unitsAddLeft;
                offsetY += unitsAddTop;

                redrawCanvas();
            }
            prevTouches[0] = event.touches[0];
            prevTouches[1] = event.touches[1];
        }

        function onTouchEnd(event) {
            singleTouch = false;
            doubleTouch = false;
        }
    </script>
</body>

</html>
